"use strict";(self.webpackChunkstudent_to_software_engineer=self.webpackChunkstudent_to_software_engineer||[]).push([[2660],{4446:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>a,contentTitle:()=>l,default:()=>p,frontMatter:()=>r,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"technical-skill-roadmap/essential-application-development/solid-principals","title":"5.2.6. SOLID Principles","description":"As you grow more comfortable with object-oriented programming, you\u2019ll eventually run into messy codebases\u2014maybe even your own. Classes get bloated. Functions do too much. Making one change breaks something else. That\u2019s where the SOLID principles come in.","source":"@site/docs/5-technical-skill-roadmap/2-essential-application-development/6-solid-principals.md","sourceDirName":"5-technical-skill-roadmap/2-essential-application-development","slug":"/technical-skill-roadmap/essential-application-development/solid-principals","permalink":"/docs/technical-skill-roadmap/essential-application-development/solid-principals","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/5-technical-skill-roadmap/2-essential-application-development/6-solid-principals.md","tags":[],"version":"current","sidebarPosition":6,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"5.2.5. Unit Tests","permalink":"/docs/technical-skill-roadmap/essential-application-development/unit-tests"},"next":{"title":"5.2.7. Data Structures and Algorithms","permalink":"/docs/technical-skill-roadmap/essential-application-development/data-structures-and-algorithms"}}');var t=s(4848),o=s(8453);const r={},l="5.2.6. SOLID Principles",a={},c=[{value:"What Does SOLID Stand For?",id:"what-does-solid-stand-for",level:2},{value:"<strong>S \u2014 Single Responsibility Principle</strong>",id:"s--single-responsibility-principle",level:3},{value:"<strong>O \u2014 Open/Closed Principle</strong>",id:"o--openclosed-principle",level:3},{value:"<strong>L \u2014 Liskov Substitution Principle</strong>",id:"l--liskov-substitution-principle",level:3},{value:"<strong>I \u2014 Interface Segregation Principle</strong>",id:"i--interface-segregation-principle",level:3},{value:"<strong>D \u2014 Dependency Inversion Principle</strong>",id:"d--dependency-inversion-principle",level:3}];function d(e){const n={h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",strong:"strong",...(0,o.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"526-solid-principles",children:"5.2.6. SOLID Principles"})}),"\n",(0,t.jsxs)(n.p,{children:["As you grow more comfortable with object-oriented programming, you\u2019ll eventually run into messy codebases\u2014maybe even your own. Classes get bloated. Functions do too much. Making one change breaks something else. That\u2019s where the ",(0,t.jsx)(n.strong,{children:"SOLID principles"})," come in."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"SOLID"})," is an acronym for five design principles that help you write code that is easier to maintain, scale, and reason about. They\u2019re not rules you must follow 100% of the time\u2014but they\u2019re extremely useful guidelines, especially when your code starts to grow."]}),"\n",(0,t.jsx)(n.h2,{id:"what-does-solid-stand-for",children:"What Does SOLID Stand For?"}),"\n",(0,t.jsx)(n.p,{children:"Here\u2019s a breakdown of each principle with simple explanations and beginner-friendly examples."}),"\n",(0,t.jsx)(n.h3,{id:"s--single-responsibility-principle",children:(0,t.jsx)(n.strong,{children:"S \u2014 Single Responsibility Principle"})}),"\n",(0,t.jsx)(n.p,{children:"A class should have only one responsibility."}),"\n",(0,t.jsxs)(n.p,{children:["Each class or module should focus on doing ",(0,t.jsx)(n.strong,{children:"one thing well"}),". If your class is handling file input, parsing data, and sending emails\u2014that\u2019s three responsibilities. If the file format changes, or the email logic needs tweaking, you now have to untangle all that logic in one place."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Why it matters:"})," Smaller, focused classes are easier to understand, test, and change without unintended side effects."]}),"\n",(0,t.jsx)(n.h3,{id:"o--openclosed-principle",children:(0,t.jsx)(n.strong,{children:"O \u2014 Open/Closed Principle"})}),"\n",(0,t.jsx)(n.p,{children:"Software entities should be open for extension, but closed for modification."}),"\n",(0,t.jsxs)(n.p,{children:["You should be able to ",(0,t.jsx)(n.strong,{children:"add new functionality"})," without modifying existing code. This often involves using ",(0,t.jsx)(n.strong,{children:"abstraction"}),"\u2014for example, defining an interface that your code can depend on, and letting new classes implement that interface."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Why it matters:"})," Reduces the risk of breaking existing features when adding new ones."]}),"\n",(0,t.jsx)(n.h3,{id:"l--liskov-substitution-principle",children:(0,t.jsx)(n.strong,{children:"L \u2014 Liskov Substitution Principle"})}),"\n",(0,t.jsx)(n.p,{children:"Objects of a superclass should be replaceable with objects of a subclass."}),"\n",(0,t.jsx)(n.p,{children:"If a function works with a base class, it should also work if you pass in any subclass\u2014without altering the behavior or breaking the app. Violating this principle leads to bugs that are hard to catch."}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Why it matters:"})," Helps you write polymorphic code that behaves consistently, even with subclasses."]}),"\n",(0,t.jsx)(n.h3,{id:"i--interface-segregation-principle",children:(0,t.jsx)(n.strong,{children:"I \u2014 Interface Segregation Principle"})}),"\n",(0,t.jsx)(n.p,{children:"Clients should not be forced to depend on interfaces they do not use."}),"\n",(0,t.jsx)(n.p,{children:"It\u2019s better to have several small, specific interfaces rather than one large, general-purpose interface. This keeps things modular and avoids situations where you\u2019re forced to implement irrelevant methods just to satisfy a bloated interface."}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Why it matters:"})," Makes your codebase cleaner and more flexible to change."]}),"\n",(0,t.jsx)(n.h3,{id:"d--dependency-inversion-principle",children:(0,t.jsx)(n.strong,{children:"D \u2014 Dependency Inversion Principle"})}),"\n",(0,t.jsx)(n.p,{children:"High-level modules should not depend on low-level modules. Both should depend on abstractions."}),"\n",(0,t.jsxs)(n.p,{children:["Instead of hardcoding concrete dependencies, classes should rely on ",(0,t.jsx)(n.strong,{children:"abstractions"})," (e.g., interfaces). This makes your code more flexible and easier to test."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Why it matters:"})," Improves modularity and allows swapping out parts of your system (e.g., different databases or APIs) with minimal changes."]})]})}function p(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>r,x:()=>l});var i=s(6540);const t={},o=i.createContext(t);function r(e){const n=i.useContext(o);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:r(e.components),i.createElement(o.Provider,{value:n},e.children)}}}]);